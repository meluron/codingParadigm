{
  // Paste it to VS Code python.json to add these snippets.
  
	"FC": {
		"prefix": "fc",
		"body": [
			"\"\"\"",
			"Author: Ankit Anand",
			"Created on: ${1:DATE}",
			"\"\"\"",
			"",
			"from FBC import FBC",
			"",
			"class ${2}(FBC):",
			"\t\"\"\"",
			"\t${3}",
			"\n\tArgs",
			"\t----",
			"\t${4}",
			"\n\tReturns",
			"\t--------",
			"\t",
			"\n\t\"\"\"",
			"",
			"\tdef __init__(self):",
			"\t\t\"\"\"set parameters\"\"\"",
			"\t\tsuper().__init__()  # pass the parameters as kwargs",
			"",
			"\tdef test(self):",
			"\t\t\"\"\"runs custom tests on function\"\"\"",
			"\n\t\tpass",
			"",
			"\tdef validate(self):",
			"\t\t\"\"\"validate inputs\"\"\"",
			"",
			"\t\tfor k, v in self.inps.items():  # validating if input is passed",
			"\t\t\tif v is None:",
			"\t\t\t\traise PermissionError(f\"inputs ({k}) need to be initialized before calling run\")",
			"",
			"\tdef run(self, debugMode=False):",
			"\t\t\"\"\"main implementation of the code\"\"\"",
			"",
			"\t\tself.ran = True  # flag to check if run command was called",
			"\t\tself.debugMode = debugMode  # turn on debug mode",
			"\t\tself.validate()  # inputs validation",
			"",
			"\t\t# INPS EXTRACTION",
			"",
			"\t\t# LOGIC IMPLEMENTATION",
			"\n\t\tpass",
			"",
			"\t\t# OUPUTS",
			"",
			"\t\t# DEBUGS",
			"\t\tif self.debugMode:",
			"\t\t\tself.debugs = {}  # add all the debug variables",
			"",
			"\t\treturn self",
			"",
			"\tdef plot(self, show=False):",
			"\t\t\"\"\"plot to debug\"\"\"",
			"",
			"\t\tif not self.ran:",
			"\t\t\traise PermissionError(\"run method needs to be called before plotting\")",
			"",
			"\t\tpass",
			"",
			"\tdef save(self, outputPath=None):",
			"\t\t\"\"\"save debug/output files\"\"\"",
			"",
			"\t\tfrom pathlib import Path",
			"",
			"\t\tif not self.ran:",
			"\t\t\traise PermissionError(\"run method needs to be called before saving output\")",
			"\t\tif outputPath is None:",
			"\t\t\traise ValueError(\"outputPath can't be None\")",
			"\t\tif isinstance(outputPath, str):",
			"\t\t\toutputPath = Path(outputPath)",
			"\t\tif not outputPath.exists():",
			"\t\t\toutputPath.mkdir(exist_ok=True, parents=True)",
			"",
			"\t\tpass"
		],
		"description": "Creates a Python class with FBC base class boilerplate"
	},
	"FBC": {
		"prefix": "FBC",
		"body": [
			"\"\"\"",
			"Author: Ankit Anand",
			"Created on: 23/01/25",
			"\"\"\"",
			"",
			"from pathlib import Path",
			"import logging",
			"",
			"class FBC:",
			"\t\"\"\"Functional Base Class (by Ankit Anand)\"\"\"",
			"",
			"\tdef __init__(self, *args, **kwargs):",
			"\t\t\"\"\"set parameters\"\"\"",
			"",
			"\t\tself.inps = kwargs if kwargs else {}",
			"",
			"\t\tself.outs = {",
			"\t\t\t# this will be returned on call",
			"\t\t}",
			"",
			"\t\tself.debugs = {",
			"\t\t\t\"logLevel\": \"INFO\",",
			"\t\t\t\"logFp\": None  #Path(__file__).resolve().parents[0]/\"log.txt\"",
			"\t\t}",
			"\t\tself.debugMode = False",
			"\t\tself.ran = False",
			"",
			"\t\tself.logger = self._getLogger(self.debugs[\"logLevel\"], self.debugs[\"logFp\"])",
			"",
			"\tdef info(self):",
			"\t\t\"\"\"returns methods and params available\"\"\"",
			"",
			"\t\tprint(f\"\\nINFO about FC <{self.__class__.__name__}>\")",
			"\t\tprint(\"-\"*45)",
			"\t\tprint(self.__doc__)",
			"\t\tprint(\"-\"*45)",
			"\t\tprint(f\"\\n:: METHODS\")",
			"\t\tfor method in self._methods():",
			"\t\t\tprint(f\"  - {method}\")",
			"",
			"\t\tprint(f\"\\n:: INPS\")",
			"\t\tfor k, v in self.inps.items():",
			"\t\t\tprint(f\"  - {k} [{type(v)}]\")",
			"",
			"\t\tprint(f\"\\n:: DEBUGS\")",
			"\t\tfor k, v in self.debugs.items():",
			"\t\t\tprint(f\"  - {k} [{type(v)}]\")",
			"",
			"\t\tprint(f\"\\n:: OUTS\")",
			"\t\tfor k, v in self.outs.items():",
			"\t\t\tprint(f\"  - {k} [{type(v)}]\")",
			"",
			"\tdef _methods(self):",
			"\t\t\"\"\"returns methods as a list\"\"\"",
			"",
			"\t\treturn [",
			"\t\t\tmethod for method in self.__dir__()",
			"\t\t\tif callable(getattr(self, method))  # ensure it's a callable (method)",
			"\t\t\tand not method.startswith(\"_\")  # excludes special methods (e.g., __init__)",
			"\t\t\tand method != \"methods\"  # exclude the methods() function itself",
			"\t\t]",
			"",
			"\tdef _getLogger(self, logLevel:str, logFp:str|Path):",
			"\t\t\"\"\"log info about function calls, call it from the run function, wherever needed\"\"\"",
			"",
			"\t\tnumericLevel = logging.getLevelName(logLevel.upper())",
			"\t\tif isinstance(numericLevel, int):",
			"\t\t\tlogLevel = numericLevel",
			"\t\telse:",
			"\t\t\tlogLevel = logging.INFO",
			"",
			"\t\tlogging.basicConfig(",
			"\t\t\tlevel=logLevel,",
			"\t\t\tformat=(",
			"\t\t\t\t\"%(asctime)s - File: %(filename)s - Function: %(funcName)s \"",
			"\t\t\t\t\"- Line: %(lineno)d - Level: %(levelname)s - Message: %(message)s\"",
			"\t\t\t),",
			"\t\t\tdatefmt=\"%d %b %Y, %H:%M:%S\",",
			"\t\t)",
			"",
			"\t\t# If logFp is not None, log to the specified file",
			"\t\tif logFp:",
			"\t\t\tfile_handler = logging.FileHandler(logFp)",
			"\t\t\tfile_handler.setFormatter(logging.Formatter(",
			"\t\t\t\t\"%(asctime)s - File: %(filename)s - Function: %(funcName)s \"",
			"\t\t\t\t\"- Line: %(lineno)d - Level: %(levelname)s - Message: %(message)s\",",
			"\t\t\t\tdatefmt=\"%d %b %Y, %H:%M:%S\"",
			"\t\t\t))",
			"\t\t\tlogging.getLogger().addHandler(file_handler)",
			"",
			"\t\treturn logging.getLogger()"
		],
		"description": "Creates a Functional Base Class (FBC) template with logging"
	}
}
