{
	// Paste it to VS Code python.json to add these snippets.
	"FC": {
		"prefix": "fc",
		"body": [
			"\"\"\"",
			"Author: Ankit Anand",
			"Created on: $CURRENT_DATE/$CURRENT_MONTH/$CURRENT_YEAR",
			"\"\"\"",
			"",
			"from FBC import FBC",
			"",
			"class ${2:functionName}(FBC):",
			"\t\"\"\"",
			"\t${3}",
			"\n\tArgs",
			"\t----",
			"\t${4}",
			"\n\tReturns",
			"\t--------",
			"\t",
			"\n\t\"\"\"",
			"",
			"\tdef __init__(self):",
			"\t\t\"\"\"Set parameters\"\"\"",
			"\t\tsuper().__init__()  # Pass the parameters as kwargs",
			"",
			"\tdef test(self):",
			"\t\t\"\"\"Runs custom tests on function\"\"\"",
			"\n\t\tpass",
			"",
			"\tdef validate(self):",
			"\t\t\"\"\"Validate inputs\"\"\"",
			"",
			"\t\tfor k, v in self.inps.items():  # Validating if input is passed",
			"\t\t\tif v is None:",
			"\t\t\t\traise PermissionError(f\"Inputs ({k}) need to be initialized before calling run\")",
			"",
			"\tdef run(self, debugMode=False):",
			"\t\t\"\"\"Main implementation of the code\"\"\"",
			"",
			"\t\tself.ran = True  # Flag to check if run command was called",
			"\t\tself.debugMode = debugMode  # Turn on debug mode",
			"\t\tself.validate()  # Inputs validation",
			"",
			"\t\t# INPS EXTRACTION",
			"",
			"\t\t# LOGIC IMPLEMENTATION",
			"\n\t\tpass",
			"",
			"\t\t# OUPUTS",
			"",
			"\t\t# DEBUGS",
			"\t\tif self.debugMode:",
			"\t\t\tself.debugs = {}  # Add all the debug variables",
			"",
			"\t\treturn self",
			"",
			"\tdef plot(self, show=False):",
			"\t\t\"\"\"plot to debug\"\"\"",
			"",
			"\t\tif not self.ran:",
			"\t\t\traise PermissionError(\"run method needs to be called before plotting\")",
			"",
			"\t\tpass",
			"",
			"\tdef save(self, outputPath=None):",
			"\t\t\"\"\"Save debug/output files\"\"\"",
			"",
			"\t\tfrom pathlib import Path",
			"",
			"\t\tif not self.ran:",
			"\t\t\traise PermissionError(\"run method needs to be called before saving output\")",
			"\t\tif outputPath is None:",
			"\t\t\traise ValueError(\"outputPath can't be None\")",
			"\t\tif isinstance(outputPath, str):",
			"\t\t\toutputPath = Path(outputPath)",
			"\t\tif not outputPath.exists():",
			"\t\t\toutputPath.mkdir(exist_ok=True, parents=True)",
			"",
			"\t\tpass"
		],
		"description": "Creates a Python class with FBC base class boilerplate"
	},
	"FBC": {
		"prefix": "fbc",
		"description": "Functional Base Class with Logging by Ankit Anand",
		"body": [
			"\"\"\"",
			"Author: Ankit Anand",
			"Created on: $CURRENT_DATE/$CURRENT_MONTH/$CURRENT_YEAR",
			"\"\"\"",
			"",
			"from pathlib import Path",
			"import sys",
			"import logging",
			"from logging.handlers import RotatingFileHandler",
			"",
			"LOG_LEVEL = \"WARNING\"",
			"LOG_FP = Path(\"./log.txt\")",
			"",
			"class LogColorFormatter(logging.Formatter):",
			"    \"\"\"Formatter to add colors to log messages in the console.\"\"\"",
			"",
			"    COLOR_CODES = {",
			"        \"DEBUG\": \"\\u001b[94m\",  # Blue",
			"        \"INFO\": \"\\u001b[92m\",   # Green",
			"        \"WARNING\": \"\\u001b[93m\",  # Yellow",
			"        \"ERROR\": \"\\u001b[91m\",  # Red",
			"        \"CRITICAL\": \"\\u001b[95m\"  # Magenta",
			"    }",
			"    RESET_CODE = \"\\u001b[0m\"",
			"",
			"    def format(self, record):",
			"        logMsg = super().format(record)",
			"        color = self.COLOR_CODES.get(record.levelname, self.RESET_CODE)",
			"        return f\"{color}{logMsg}{self.RESET_CODE}\"",
			"",
			"class FBC:",
			"    \"\"\"Functional Base Class (by Ankit Anand)\"\"\"",
			"",
			"    def __init__(self, *args, **kwargs):",
			"        \"\"\"Set parameters\"\"\"",
			"",
			"        self.inps = kwargs if kwargs else {}",
			"        self.outs = {}  # This will be returned on call",
			"",
			"        self.debugs = {",
			"            \"logLevel\": LOG_LEVEL,",
			"            \"logFp\": LOG_FP",
			"        }",
			"        self.debugMode = False",
			"        self.ran = False",
			"",
			"        self.logger = self._getLogger(self.debugs[\"logLevel\"], self.debugs[\"logFp\"])",
			"",
			"    def info(self):",
			"        \"\"\"Returns methods and params available\"\"\"",
			"        print(f\"\\nINFO about FC <{self.__class__.__name__}>\")",
			"        print(\"-\" * 45)",
			"        print(self.__doc__)",
			"        print(\"-\" * 45)",
			"        print(\"\\n:: METHODS\")",
			"        for method in self._methods():",
			"            print(f\"  - {method}\")",
			"",
			"        print(\"\\n:: INPS\")",
			"        for k, v in self.inps.items():",
			"            print(f\"  - {k} [{type(v)}]\")",
			"",
			"        print(\"\\n:: DEBUGS\")",
			"        for k, v in self.debugs.items():",
			"            print(f\"  - {k} [{type(v)}]\")",
			"",
			"        print(\"\\n:: OUTS\")",
			"        for k, v in self.outs.items():",
			"            print(f\"  - {k} [{type(v)}]\")",
			"",
			"    def _methods(self):",
			"        \"\"\"Returns methods as a list\"\"\"",
			"        return [",
			"            method for method in self.__dir__()",
			"            if callable(getattr(self, method))",
			"            and not method.startswith(\"_\")",
			"            and method != \"methods\"",
			"        ]",
			"",
			"    def _getLogger(self, logLevel: str, logFp: str | Path):",
			"        \"\"\"Log function calls, supporting colored console logs and rotating file logs.\"\"\"",
			"",
			"        logLevel = logging._nameToLevel.get(logLevel.upper(), logging.INFO)",
			"",
			"        logger = logging.getLogger(self.__class__.__name__)",
			"",
			"        # Prevent duplicate handlers",
			"        if not logger.hasHandlers():",
			"            logger.setLevel(logLevel)",
			"",
			"            formatter = logging.Formatter(",
			"                \"%(asctime)s - File: %(filename)s - Function: %(funcName)s \"",
			"                \"- Line: %(lineno)d - Level: %(levelname)s - Message: %(message)s\",",
			"                datefmt=\"%d %b %Y, %H:%M:%S\"",
			"            )",
			"",
			"            # ðŸŽ¨ Console Handler with Colors",
			"            consoleHandler = logging.StreamHandler(sys.stdout)",
			"            consoleHandler.setFormatter(LogColorFormatter(formatter._fmt))",
			"            logger.addHandler(consoleHandler)",
			"",
			"            # ðŸ“‚ Rotating File Handler",
			"            if logFp:",
			"                fileHandler = RotatingFileHandler(",
			"                    str(logFp), maxBytes=1_000_000, backupCount=5  # 1MB per file, keep 5 backups",
			"                )",
			"                fileHandler.setFormatter(formatter)",
			"                logger.addHandler(fileHandler)",
			"",
			"        return logger"
		]
	}
}
